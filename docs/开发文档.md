# 电梯乘运质量文档自动化处理系统 - 开发文档

## 1. 项目概述

### 1.1 功能流程

```
导入原始记录 → 导入测试报告 → 添加图片 → OCR识别 → 编辑结果 → 确认填入 → 生成文档
```

### 1.2 输入输出

**输入**：
- 原始记录Word文档（.docx）
- 测试报告Word文档（.docx）
- 图片文件（JPG/PNG/BMP）

**输出**：
- RTE-JCXXXXXXX.docx（原始记录）
- BIE-JCXXXXXXX.docx（测试报告）

---

## 2. 功能需求

### 2.1 文档管理

| 功能 | 说明 |
|-----|------|
| 导入原始记录 | 选择并加载原始记录Word文件 |
| 导入测试报告 | 选择并加载测试报告Word文件 |
| 解析表格 | 识别文档中的可填写表格和字段 |
| 预览文档 | 显示文档内容和填写状态 |

### 2.2 图片处理

| 功能 | 说明 |
|-----|------|
| 添加图片 | 选择一张图片进行OCR识别 |
| OCR识别 | 识别图片中的文字内容 |
| 结果展示 | 显示识别出的文字 |
| 结果编辑 | 用户可修改识别结果 |

### 2.3 字段标记与映射配置

用户需要在Word文档需要填写内容的地方标注标记符，程序根据标记符的位置和映射配置进行数据填写。

#### 2.3.1 标记符格式

标记符格式为 `[编号]`，例如：`[1]`、`[2]`、`[3]` 等。用户在Word文档的任意位置（表格内或表格外）插入标记符，程序会自动识别这些位置并记录。

#### 2.3.2 标记符定义

**测试报告（BIE-JC）标记符**：

| 标记符 | 字段名称 | 说明 |
|-------|---------|------|
| [1] | 报告编号后缀 | BIE-JCXXXXXX中的XXXXXX（7位数字） |
| [2] | 使用单位 | 电梯的使用单位名称 |
| [3] | 委托单位 | 电梯检测的委托单位名称 |
| [4] | 检测日期 | 电梯检测的日期 |
| [5] | 设备使用地点 | 电梯的安装使用地点 |
| [6] | 设备品种 | 电梯类型（如乘客电梯、货梯等） |
| [7] | 型号 | 电梯型号 |
| [8] | 制造单位 | 电梯制造单位名称 |
| [9] | 额定载重量 | 电梯额定载重（单位：kg） |
| [10] | 产品编号 | 电梯产品编号 |
| [11] | 层站门数 | 电梯层站门数（如 12/12/12） |
| [12] | 额定速度 | 电梯额定速度（单位：m/s） |

**原始记录（RTE-JC）标记符**：

| 标记符 | 字段名称 | 说明 |
|-------|---------|------|
| [1] | 报告编号后缀 | RTE-JCXXXXXX中的XXXXXX（7位数字） |
| [2] | 使用单位 | 电梯的使用单位名称 |
| [3] | 委托单位 | 电梯检测的委托单位名称 |
| [4] | 检测日期 | 电梯检测的日期 |
| [5] | 设备使用地点 | 电梯的安装使用地点 |
| [6] | 设备品种 | 电梯类型（如乘客电梯、货梯等） |
| [7] | 型号 | 电梯型号 |
| [8] | 制造单位 | 电梯制造单位名称 |
| [9] | 额定载重量 | 电梯额定载重（单位：kg） |
| [10] | 产品编号 | 电梯产品编号 |
| [11] | 层站门数 | 电梯层站门数（如 12/12/12） |
| [12] | 额定速度 | 电梯额定速度（单位：m/s） |

#### 2.3.3 映射配置

程序识别到文档中的标记符后，用户需要配置每个标记符对应的OCR识别字段。映射关系可以在首次使用时配置，也可以在配置文件中保存。

### 2.4 数据填写

| 功能 | 说明 |
|-----|------|
| 识别标记 | 自动识别文档中的 `[1]`、`[2]` 等标记符位置 |
| 配置映射 | 配置标记符与OCR识别字段的对应关系 |
| 确认填入 | 用户确认后将数据写入标记位置 |
| 生成文档 | 输出两个带编号的Word文件 |

### 2.5 使用流程示例

```
1. 用户在Word文档中需要填写的地方插入标记符，例如：
   测试报告：在报告编号位置插入 [1]，在使用单位位置插入 [2]，依此类推
   原始记录：在报告编号位置插入 [1]，在使用单位位置插入 [2]，依此类推

2. 程序加载文档后自动识别所有标记符位置

3. 用户进行OCR识别，得到识别结果

4. 用户确认映射关系（系统自动按顺序匹配）
   [1] → 报告编号后缀
   [2] → 使用单位
   ...

5. 用户确认后，程序将识别结果填入对应的标记位置

6. 程序生成输出文档（RTE-JCXXXXXX.docx 和 BIE-JCXXXXXX.docx）
```

---

## 3. 技术架构

### 3.1 开发框架

- **.NET 8.0** - 开发框架
- **WinForms** - UI框架
- **Microsoft.Extensions.DependencyInjection** - 依赖注入容器
- **NPOI** - Word文档处理
- **腾讯云OCR** - 表格识别（复用 table_OCRV41ForCsharp_net 项目）

### 3.2 系统结构（依赖注入模式）

```
┌─────────────────────────────────────────────────────────────────┐
│                         ServiceProvider                          │
│                    (依赖注入容器统一管理服务)                      │
└─────────────────────────────────────────────────────────────────┘
                                │
        ┌───────────────────────┼───────────────────────┐
        │                       │                       │
        ▼                       ▼                       ▼
┌───────────────┐       ┌───────────────┐       ┌───────────────┐
│  IWordService │       │  IOcrService  │       │MainForm (注入) │
│               │       │               │       │               │
│ - LoadDocument│       │ - Recognize   │       │ - _wordService│
│ - ParseTables │       │ - Preprocess  │       │ - _ocrService│
│ - FillCell    │       │               │       │               │
│ - SaveAs      │       │               │       │               │
└───────┬───────┘       └───────┬───────┘       └───────────────┘
        │                       │
        ▼                       ▼
┌───────────────┐       ┌───────────────┐
│WordService    │       │TencentOcrService│
│(具体实现)      │       │(复用已有实现)   │
└───────────────┘       └───────────────┘
```

### 3.3 腾讯OCR服务架构

复用 table_OCRV41ForCsharp_net 项目中的腾讯OCR实现：

```
┌─────────────────────────────────────────────────────────────┐
│                      IOcrService (接口)                      │
│                  string RecognizeTable(string imageBase64)  │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                   TencentOcrService                         │
│  - SecretId/SecretKey (从key.json读取)                      │
│  - RecognizeTableAccurateOCR (精准表格识别)                  │
│  - 重试机制 (3次重试，指数退避)                               │
│  - TC3-HMAC-SHA256 签名                                      │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                    腾讯云OCR API                             │
│  POST https://ocr.tencentcloudapi.com                       │
│  Action: RecognizeTableAccurateOCR                         │
│  Region: ap-guangzhou                                       │
└─────────────────────────────────────────────────────────────┘
```

### 3.4 服务接口定义

```csharp
// OCR识别服务接口
public interface IOcrService
{
    string RecognizeTable(string imageBase64);
}

// 密钥服务接口
public interface IKeyService
{
    KEY CheckKey();
}

// 密钥模型
public class KEY
{
    public string API_KEY { get; set; }
    public string SECRET_KEY { get; set; }
}

// 图片转Base64服务接口
public interface IGetFileContentAsBase64Service
{
    string GetFileContentAsBase64(string filePath);
}

// Word文档处理服务接口
public interface IWordService
{
    DocumentInfo LoadDocument(string filePath);
    List<TableInfo> ParseTables(DocumentInfo doc);
    void FillCell(DocumentInfo doc, int tableIndex, int row, int column, string value);
    void SaveAs(DocumentInfo doc, string outputPath, string title);
    void ReplaceTitle(DocumentInfo doc, string newTitle);
}

// 服务工厂接口（用于解决依赖）
public interface IServiceFactory<T>
{
    T Create();
}
```

### 3.5 腾讯OCR服务实现

```csharp
public class TencentOcrService : IOcrService
{
    private readonly string _secretId;
    private readonly string _secretKey;
    private readonly string _service = "ocr";
    private readonly string _version = "2018-11-19";
    private readonly string _action = "RecognizeTableAccurateOCR";
    private readonly string _region = "ap-guangzhou";
    private static readonly HttpClient Client = new HttpClient();

    public TencentOcrService(string secretId, string secretKey)
    {
        _secretId = secretId;
        _secretKey = secretKey;
    }

    public string RecognizeTable(string imageBase64)
    {
        int maxRetries = 3;
        int retryCount = 0;
        Exception lastException = null;

        while (retryCount < maxRetries)
        {
            try
            {
                return DoRequest(_secretId, _secretKey, _service, _version, 
                                 _action, imageBase64, _region, "");
            }
            catch (Exception ex)
            {
                lastException = ex;
                retryCount++;
                if (retryCount >= maxRetries) break;
                Thread.Sleep((int)Math.Pow(2, retryCount) * 1000);
            }
        }

        throw new OcrServiceException($"OCR服务调用失败，已重试{maxRetries}次", lastException);
    }

    private string DoRequest(string secretId, string secretKey, string service, 
                            string version, string action, string body, string region, string token)
    {
        var host = "ocr.tencentcloudapi.com";
        var url = "https://" + host;
        var contentType = "application/json; charset=utf-8";
        var timestamp = ((int)DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1)).TotalSeconds).ToString();
        var auth = GetAuth(secretId, secretKey, host, contentType, timestamp, body);

        var request = new HttpRequestMessage();
        request.Method = HttpMethod.Post;
        request.Headers.Add("Host", host);
        request.Headers.Add("X-TC-Timestamp", timestamp);
        request.Headers.Add("X-TC-Version", version);
        request.Headers.Add("X-TC-Action", action);
        request.Headers.Add("X-TC-Region", region);
        request.Headers.Add("X-TC-Token", token);
        request.Headers.Add("X-TC-RequestClient", "SDK_NET_BAREBONE");
        request.Headers.TryAddWithoutValidation("Authorization", auth);
        request.RequestUri = new Uri(url);
        request.Content = new StringContent(body, MediaTypeWithQualityHeaderValue.Parse(contentType));

        var response = Client.Send(request);
        if (!response.IsSuccessStatusCode)
        {
            throw new OcrServiceException($"HTTP请求失败，状态码: {response.StatusCode}");
        }
        return response.Content.ReadAsStringAsync().Result;
    }

    private string GetAuth(string secretId, string secretKey, string host, 
                          string contentType, string timestamp, string body)
    {
        var canonicalURI = "/";
        var canonicalHeaders = "content-type:" + contentType + "\nhost:" + host + "\n";
        var signedHeaders = "content-type;host";
        var hashedRequestPayload = Sha256Hex(body);
        var canonicalRequest = "POST\n" + canonicalURI + "\n\n" + 
                              canonicalHeaders + "\n" + signedHeaders + "\n" + hashedRequestPayload;

        var algorithm = "TC3-HMAC-SHA256";
        var date = DateTime.Parse("1970-01-01").AddSeconds(int.Parse(timestamp)).ToString("yyyy-MM-dd");
        var service = host.Split(".")[0];
        var credentialScope = date + "/" + service + "/" + "tc3_request";
        var hashedCanonicalRequest = Sha256Hex(canonicalRequest);
        var stringToSign = algorithm + "\n" + timestamp + "\n" + 
                          credentialScope + "\n" + hashedCanonicalRequest;

        var tc3SecretKey = Encoding.UTF8.GetBytes("TC3" + secretKey);
        var secretDate = HmacSha256(tc3SecretKey, Encoding.UTF8.GetBytes(date));
        var secretService = HmacSha256(secretDate, Encoding.UTF8.GetBytes(service));
        var secretSigning = HmacSha256(secretService, Encoding.UTF8.GetBytes("tc3_request"));
        var signatureBytes = HmacSha256(secretSigning, Encoding.UTF8.GetBytes(stringToSign));
        var signature = BitConverter.ToString(signatureBytes).Replace("-", "").ToLower();

        return algorithm + " Credential=" + secretId + "/" + credentialScope + 
               ", SignedHeaders=" + signedHeaders + ", Signature=" + signature;
    }

    private static string Sha256Hex(string s)
    {
        using (SHA256 algo = SHA256.Create())
        {
            byte[] hashbytes = algo.ComputeHash(Encoding.UTF8.GetBytes(s));
            var sb = new StringBuilder();
            foreach (byte b in hashbytes) sb.Append(b.ToString("x2"));
            return sb.ToString();
        }
    }

    private static byte[] HmacSha256(byte[] key, byte[] msg)
    {
        using (HMACSHA256 mac = new HMACSHA256(key))
        {
            return mac.ComputeHash(msg);
        }
    }
}
```

### 3.6 密钥管理服务

```csharp
public class KeyService : IKeyService
{
    public KEY CheckKey()
    {
        var myKey = new KEY();
        string keyPath = System.Environment.CurrentDirectory + @"\key.json";

        if (!File.Exists(keyPath))
        {
            MessageBox.Show("密钥文件缺失，请配置后重试");
            Console.WriteLine("请输入API_KEY (SecretId):");
            do { myKey.API_KEY = Console.ReadLine(); } while (string.IsNullOrEmpty(myKey.API_KEY));
            Console.WriteLine("请输入SECRET_KEY:");
            do { myKey.SECRET_KEY = Console.ReadLine(); } while (string.IsNullOrEmpty(myKey.SECRET_KEY));

            string keyJson = JsonConvert.SerializeObject(myKey);
            File.WriteAllText(keyPath, keyJson);
        }
        else
        {
            string keyJson = File.ReadAllText(keyPath);
            myKey = JsonConvert.DeserializeObject<KEY>(keyJson);
        }
        return myKey;
    }
}
```

### 3.4 依赖注入配置

```csharp
// 在Program.cs中配置依赖注入
var services = new ServiceCollection();

services.AddScoped<IWordService, WordService>();
services.AddScoped<IOCRService, OCRService>();
services.AddScoped<MainForm>();

using var serviceProvider = services.BuildServiceProvider();
var mainForm = serviceProvider.GetRequiredService<MainForm>();
Application.Run(mainForm);
```

---

## 4. 数据模型

```csharp
// 文档信息
public class DocumentInfo
{
    public string FilePath { get; set; }
    public string FileName { get; set; }
    public string Title { get; set; }
    public List<TableInfo> Tables { get; set; } = new();
    public List<MarkerInfo> Markers { get; set; } = new(); // 文档中的标记符列表
}

// 表格信息
public class TableInfo
{
    public int TableIndex { get; set; }
    public List<CellInfo> Cells { get; set; } = new();
}

// 单元格信息
public class CellInfo
{
    public int Row { get; set; }
    public int Column { get; set; }
    public string Value { get; set; }
    public bool IsEmpty { get; set; }
}

// 标记符信息
public class MarkerInfo
{
    public string MarkerId { get; set; }        // 例如 "[1]"
    public string Description { get; set; }     // 例如 "报告编号"
    public int ParagraphIndex { get; set; }     // 段落索引
    public int RunIndex { get; set; }           // TextRun索引
    public int Position { get; set; }           // 在TextRun中的位置
}

// OCR识别结果 (从腾讯OCR返回的JSON解析)
public class OCRResult
{
    public string ImagePath { get; set; }
    public string RawJson { get; set; }         // 原始JSON响应
    public DateTime RecognitionTime { get; set; }
    public List<OCRField> Fields { get; set; } = new(); // 解析后的字段列表
}

// OCR识别字段
public class OCRField
{
    public string Name { get; set; }      // 字段名称，如 "报告编号"
    public string Value { get; set; }     // 识别出的值
    public int Order { get; set; }        // 字段顺序（1, 2, 3...）
}

// 标记符映射配置
public class MarkerMapping
{
    public string MarkerId { get; set; }  // 例如 "[1]"
    public string FieldName { get; set; } // 对应的OCR字段名称
    public string Description { get; set; } // 标记符含义描述
}

// 项目配置
public class ProjectConfig
{
    public string OriginalDocPath { get; set; }
    public string ReportDocPath { get; set; }
    public string ReportNumber { get; set; }
    public List<MarkerMapping> Mappings { get; set; } = new(); // 标记符映射配置
    public List<MarkerInfo> DetectedMarkers { get; set; } = new(); // 检测到的标记符
}
```

### 4.1 标记符解析

```csharp
// 标记符解析正则表达式
public static class MarkerParser
{
    // 匹配 [数字] 格式的标记符
    public static readonly Regex MarkerRegex = new(@"\[(\d+)\]", RegexOptions.Compiled);

    // 从文本中提取所有标记符
    public static List<string> ExtractMarkers(string text)
    {
        var matches = MarkerRegex.Matches(text);
        return matches.Select(m => m.Value).Distinct().ToList();
    }

    // 获取标记符编号
    public static int GetMarkerNumber(string marker)
    {
        var match = MarkerRegex.Match(marker);
        return int.Parse(match.Groups[1].Value);
    }
}
```

### 4.2 映射配置文件示例

映射配置可以保存为JSON文件，方便复用。系统使用统一的字段顺序，测试报告和原始记录共用相同的字段定义：

```json
{
  "Fields": [
    { "Order": 1,  "FieldName": "reportNumberSuffix", "Description": "报告编号后缀" },
    { "Order": 2,  "FieldName": "useUnit",           "Description": "使用单位" },
    { "Order": 3,  "FieldName": "entrustUnit",       "Description": "委托单位" },
    { "Order": 4,  "FieldName": "testDate",          "Description": "检测日期" },
    { "Order": 5,  "FieldName": "deviceLocation",    "Description": "设备使用地点" },
    { "Order": 6,  "FieldName": "deviceType",        "Description": "设备品种" },
    { "Order": 7,  "FieldName": "model",             "Description": "型号" },
    { "Order": 8,  "FieldName": "manufacturer",      "Description": "制造单位" },
    { "Order": 9,  "FieldName": "ratedLoad",         "Description": "额定载重量" },
    { "Order": 10, "FieldName": "productNumber",     "Description": "产品编号" },
    { "Order": 11, "FieldName": "floorDoorCount",    "Description": "层站门数" },
    { "Order": 12, "FieldName": "ratedSpeed",        "Description": "额定速度" }
  ],
  "Documents": {
    "OriginalRecord": "RTE-JC{reportNumberSuffix}",
    "TestReport": "BIE-JC{reportNumberSuffix}"
  }
}
```

### 4.3 OCR识别结果格式

腾讯OCR精准表格识别返回JSON格式结果，解析后按以下顺序排列：

```
{
  "TextDetections": [
    { "DetectedText": "2024001", "Confidence": 95.5 },
    { "DetectedText": "某某电梯有限公司", "Confidence": 98.2 },
    { "DetectedText": "某某检测机构", "Confidence": 97.8 },
    ...
  ]
}
```

程序将识别结果按行分割，生成1、2、3...编号的字段：

```
1. 报告编号后缀: 2024001
2. 使用单位: 某某电梯有限公司
3. 委托单位: 某某检测机构
4. 检测日期: 2024-01-15
5. 设备使用地点: 某某市某某区某某路100号
6. 设备品种: 乘客电梯
7. 型号: XXX-1000
8. 制造单位: 某某电梯制造有限公司
9. 额定载重量: 1000
10. 产品编号: PN123456789
11. 层站门数: 12/12/12
12. 额定速度: 2.5
```

---

## 5. 用户界面

### 5.1 主界面布局

```
┌─────────────────────────────────────────────────────────────────────┐
│  电梯乘运质量文档处理                                        ─ □ ×  │
├─────────────────────────────────────────────────────────────────────┤
│  文档管理                                                        │
│  ┌───────────────────────────────────────────────────────────────┐│
│  │ 原始记录: [浏览...]  未加载                                ││
│  │ 测试报告: [浏览...]  未加载                                ││
│  │ 报告编号: [_______]                                         ││
│  │ 检测到标记: [1][2][3][4][5][6][7][8][9][10][11][12]        ││
│  └───────────────────────────────────────────────────────────────┘│
│                                                                      │
│  图片处理                                                           │
│  ┌───────────────────────────────────────────────────────────────┐│
│  │ [选择图片]                                                     ││
│  │ 当前图片: 未选择                                              ││
│  │ [开始识别]                                                    ││
│  └───────────────────────────────────────────────────────────────┘│
│                                                                      │
│  识别结果                                                           │
│  ┌───────────────────────────────────────────────────────────────┐│
│  │ 识别结果:                                                      ││
│  │ ┌───────────────────────────────────────────────────────────┐││
│  │ │ 1. 报告编号后缀: 2024001                                 │││
│  │ │ 2. 使用单位: 某某电梯有限公司                            │││
│  │ │ 3. 委托单位: 某某检测机构                                │││
│  │ │ 4. 检测日期: 2024-01-15                                  │││
│  │ │ 5. 设备使用地点: 某某市某某区某某路100号                │││
│  │ │ 6. 设备品种: 乘客电梯                                    │││
│  │ │ 7. 型号: XXX-1000                                        │││
│  │ │ 8. 制造单位: 某某电梯制造有限公司                        │││
│  │ │ 9. 额定载重量: 1000kg                                    │││
│  │ │ 10. 产品编号: PN123456789                                │││
│  │ │ 11. 层站门数: 12/12/12                                   │││
│  │ │ 12. 额定速度: 2.5m/s                                     │││
│  │ └───────────────────────────────────────────────────────────┘││
│  └───────────────────────────────────────────────────────────────┘│
│                                                                      │
│  标记符映射配置                                                     │
│  ┌───────────────────────────────────────────────────────────────┐│
│  │ 标记  →  字段名称                    操作                      ││
│  │ [1] → 报告编号后缀                   [1]                       ││
│  │ [2] → 使用单位                       [2]                       ││
│  │ [3] → 委托单位                       [3]                       ││
│  │ [4] → 检测日期                       [4]                       ││
│  │ [5] → 设备使用地点                   [5]                       ││
│  │ [6] → 设备品种                       [6]                       ││
│  │ [7] → 型号                           [7]                       ││
│  │ [8] → 制造单位                       [8]                       ││
│  │ [9] → 额定载重量                     [9]                       ││
│  │ [10] → 产品编号                      [10]                      ││
│  │ [11] → 层站门数                      [11]                      ││
│  │ [12] → 额定速度                      [12]                      ││
│  │ [映射配置]  [保存配置]                                          ││
│  └───────────────────────────────────────────────────────────────┘│
│                                                                      │
├─────────────────────────────────────────────────────────────────────┤
│  [预览]  [确认填入] [生成文档]                                      │
└─────────────────────────────────────────────────────────────────────┘
```

### 5.2 标记符识别与配置

当用户导入Word文档后，程序自动扫描文档中的所有标记符（如 `[1]`、`[2]`），并显示在"检测到标记"区域。用户可以在识别结果区域查看对应的OCR识别字段，并通过映射配置将标记符与识别字段关联。

### 5.3 映射配置流程

1. 程序识别文档中的 `[1]`、`[2]` 等标记符
2. 用户进行OCR识别，得到识别结果
3. 系统自动将识别结果按行分割，生成1、2、3...编号的字段
4. 用户确认或调整映射关系
5. 点击"确认填入"，程序将识别结果填入对应标记位置

---

## 6. 业务流程

### 6.1 完整流程图

```
┌──────────┐     ┌──────────┐     ┌──────────┐
│ 启动程序 │ ──▶ │ 导入原始 │ ──▶ │ 导入测试 │
│          │     │ 记录文档 │     │ 报告文档 │
└──────────┘     └──────────┘     └──────────┘
                                      │
                                      ▼
                           ┌──────────────────┐
                           │ 识别文档中的      │
                           │ 标记符 [1][2]...  │
                           └────────┬─────────┘
                                    │
                                    ▼
┌──────────┐     ┌──────────┐     ┌──────────┐
│ 选择图片 │ ──▶ │ OCR识别  │ ──▶ │ 展示结果 │
│          │     │          │     │ 可编辑   │
└──────────┘     └──────────┘     └──────────┘
                                      │
                                      ▼
                           ┌──────────────────┐
                           │  配置标记符映射   │
                           │ [1]→报告编号      │
                           │ [2]→电梯型号      │
                           └────────┬─────────┘
                                    │
                                    ▼
┌──────────┐     ┌──────────┐     ┌──────────┐
│ 用户确认 │ ──▶ │ 数据填表 │ ──▶ │ 生成文档 │
│          │     │          │     │          │
└──────────┘     └──────────┘     └──────────┘
```

### 6.2 操作步骤

1. **导入文档**：点击"浏览"按钮选择原始记录和测试报告Word文件
2. **识别标记**：程序自动扫描文档中的 `[1]`、`[2]` 等标记符并显示
3. **输入编号**：手动输入7位报告编号
4. **选择图片**：点击"选择图片"按钮添加一张图片
5. **开始识别**：点击"开始识别"执行OCR
6. **编辑结果**：在文本框中修改识别结果
7. **配置映射**：确认标记符与识别字段的对应关系
8. **确认填入**：点击"确认填入"将数据写入标记位置
9. **生成文档**：点击"生成文档"输出两个Word文件

### 6.3 标记符填写机制

当用户点击"确认填入"时，程序执行以下操作：

1. 遍历文档中所有 `[N]` 格式的标记符
2. 根据映射配置找到对应的识别结果
3. 将标记符 `[N]` 替换为识别结果的值
4. 保留文档原有格式和样式

---

## 7. 依赖配置

### 7.1 NuGet包

```xml
<PackageReference Include="Microsoft.Extensions.DependencyInjection" Version="8.0.0" />
<PackageReference Include="Microsoft.Extensions.Configuration.Json" Version="8.0.0" />
<PackageReference Include="NPOI" Version="2.7.0" />
<PackageReference Include="Newtonsoft.Json" Version="13.0.3" />
<PackageReference Include="Microsoft.Extensions.Logging" Version="8.0.0" />
<PackageReference Include="Microsoft.Extensions.Logging.Console" Version="8.0.0" />
```

### 7.2 项目结构（依赖注入模式）

```
CYZLZDH/
├── src/
│   ├── CYZLZDH.App/
│   │   ├── MainForm.cs           // 通过构造函数注入服务
│   │   ├── MainForm.Designer.cs
│   │   └── Program.cs            // 配置DI容器
│   │
│   ├── CYZLZDH.Core/
│   │   ├── Models/
│   │   │   ├── DocumentInfo.cs
│   │   │   ├── TableInfo.cs
│   │   │   ├── CellInfo.cs
│   │   │   ├── OCRResult.cs
│   │   │   └── KEY.cs            // 腾讯OCR密钥模型
│   │   ├── Services/
│   │   │   ├── Interfaces/
│   │   │   │   ├── IWordService.cs
│   │   │   │   ├── IOcrService.cs
│   │   │   │   ├── IKeyService.cs
│   │   │   │   └── IGetFileContentAsBase64Service.cs
│   │   │   ├── WordService.cs    // 实现IWordService
│   │   │   ├── TencentOcrService.cs  // 复用table_OCRV41ForCsharp_net
│   │   │   ├── KeyService.cs     // 实现IKeyService
│   │   │   └── GetFileContentAsBase64Service.cs
│   │   └── Config.cs
│   │
│   └── CYZLZDH.Tests/
│       └── ServicesTests.cs      // 可通过Mock测试
│
├── docs/
│   └── 开发文档.md
│
├── key.json                     // 腾讯OCR API密钥配置
└── CYZLZDH.sln
```

### 7.3 服务实现示例

```csharp
// KeyService.cs - 密钥管理服务
public class KeyService : IKeyService
{
    public KEY CheckKey()
    {
        var myKey = new KEY();
        string keyPath = System.Environment.CurrentDirectory + @"\key.json";

        if (!File.Exists(keyPath))
        {
            MessageBox.Show("密钥文件缺失，请配置后重试");

            Console.WriteLine("请输入API_KEY (SecretId):");
            do { myKey.API_KEY = Console.ReadLine(); } while (string.IsNullOrEmpty(myKey.API_KEY));

            Console.WriteLine("请输入SECRET_KEY:");
            do { myKey.SECRET_KEY = Console.ReadLine(); } while (string.IsNullOrEmpty(myKey.SECRET_KEY));

            string keyJson = JsonConvert.SerializeObject(myKey);
            File.WriteAllText(keyPath, keyJson);
        }
        else
        {
            string keyJson = File.ReadAllText(keyPath);
            myKey = JsonConvert.DeserializeObject<KEY>(keyJson);
        }
        return myKey;
    }
}

// WordService.cs - 实现IWordService接口
public class WordService : IWordService
{
    public DocumentInfo LoadDocument(string filePath)
    {
        // 使用NPOI加载Word文档
    }

    public List<TableInfo> ParseTables(DocumentInfo doc)
    {
        // 解析文档中的表格
    }

    public void FillCell(DocumentInfo doc, int tableIndex, int row, int column, string value)
    {
        // 填充表格单元格
    }

    public void SaveAs(DocumentInfo doc, string outputPath, string title)
    {
        // 保存文档
    }

    public void ReplaceTitle(DocumentInfo doc, string newTitle)
    {
        // 替换文档标题
    }
}

// GetFileContentAsBase64Service.cs - 图片转Base64服务
public class GetFileContentAsBase64Service : IGetFileContentAsBase64Service
{
    public string GetFileContentAsBase64(string filePath)
    {
        byte[] imageBytes = File.ReadAllBytes(filePath);
        return Convert.ToBase64String(imageBytes);
    }
}
```

### 7.4 依赖注入配置（Program.cs）

```csharp
// Program.cs - DI容器配置
using Microsoft.Extensions.DependencyInjection;

var services = new ServiceCollection();

// 注册服务
services.AddSingleton<IPathService, PathService>();
services.AddSingleton<IKeyService, KeyService>();
services.AddSingleton<IGetFileContentAsBase64Service, GetFileContentAsBase64Service>();

// 使用工厂模式注册 TencentOcrService
services.AddSingleton<IOcrService>(provider =>
{
    var keyService = provider.GetRequiredService<IKeyService>();
    var key = keyService.CheckKey();
    return new TencentOcrService(key.API_KEY, key.SECRET_KEY);
});

services.AddScoped<IWordService, WordService>();
services.AddScoped<MainForm>();

using var serviceProvider = services.BuildServiceProvider();
var mainForm = serviceProvider.GetRequiredService<MainForm>();
Application.Run(mainForm);
```

### 7.5 主窗体使用依赖注入

```csharp
// MainForm.cs - 通过构造函数注入服务
public partial class MainForm : Form
{
    private readonly IWordService _wordService;
    private readonly IOcrService _ocrService;
    private readonly IKeyService _keyService;

    // 构造函数注入 - 由DI容器自动提供实现
    public MainForm(IWordService wordService, IOcrService ocrService, IKeyService keyService)
    {
        _wordService = wordService;
        _ocrService = ocrService;
        _keyService = keyService;
        InitializeComponent();
    }

    private void btnLoadOriginal_Click(object sender, EventArgs e)
    {
        var doc = _wordService.LoadDocument(filePath);
    }

    private void btnRecognize_Click(object sender, EventArgs e)
    {
        var imageBase64 = Convert.ToBase64String(File.ReadAllBytes(imagePath));
        var result = _ocrService.RecognizeTable(imageBase64);
    }
}
```

---

## 8. 错误处理

| 错误情况 | 处理方式 |
|---------|---------|
| 文档加载失败 | 提示"无法加载文档，请检查文件格式" |
| 文档未加载 | 提示"请先导入文档" |
| 图片未选择 | 提示"请先选择图片" |
| 识别失败 | 提示"识别失败，请重试" |
| 编号为空 | 提示"请输入报告编号" |

---

## 9. 测试用例

| 测试项 | 操作 | 预期结果 |
|-------|------|---------|
| 导入文档 | 选择Word文件 | 正确加载并显示状态 |
| 解析表格 | 加载文档后 | 识别所有表格 |
| 选择图片 | 选择JPG文件 | 显示图片路径 |
| OCR识别 | 点击识别按钮 | 显示识别文字 |
| 编辑结果 | 修改文字 | 内容更新 |
| 确认填入 | 点击确认 | 数据写入表格 |
| 生成文档 | 点击生成 | 输出两个Word文件 |

---

## 10. 开发计划

| 阶段 | 内容 | 时间 |
|-----|------|------|
| 第一阶段 | 框架搭建、UI设计 | 1天 |
| 第二阶段 | 文档加载、表格解析 | 1天 |
| 第三阶段 | OCR集成、结果展示 | 1天 |
| 第四阶段 | 数据填写、文档生成 | 1天 |
| 第五阶段 | 测试、优化 | 1天 |

**预计总工期：5天**

---

**文档版本**: 2.0
**更新日期**: 2025-12-28
**文档状态**: 简化版
